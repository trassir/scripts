# -*- coding: utf-8 -*-
# <font color='green'><h3>Face from folder</h3></font><br>
# <code>Types of work:<br><ul><li>export - dump face recognizer database to screenshot folder</li>
# <li>import - upload data to face recognizer database from source on disk</li></ul>
# </code>

"""
<parameters>
<company>DSSL Mitrofanov Egor</company>
<title>Face from folder</title>
<version>2.0.1</version>
    <parameter>
        <type>string_from_list</type>
        <id>TYPE_OF_WORK</id>
        <name>Type of work</name>
        <value>export</value>
        <string_list>export,import</string_list>
    </parameter>
    <parameter>
        <id>FOLDER</id>
        <type>string</type>
        <name>Source to import</name>
        <value>{path}/face_from_folder</value>
    </parameter>
    <parameter>
        <id>DELETE_PERSONS</id>
        <name>Delete persons in db not present on source while import</name>
        <type>boolean</type>
        <value>False</value>
    </parameter>
    <parameter>
        <id>DEBUG</id>
        <name>log</name>
        <type>boolean</type>
        <value>True</value>
    </parameter>
    <resources>
        <resource>helpers.py</resource>
    </resources>
</parameters>
"""

resources = {
    "helpers.py": """
        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
    """,
}
t1utils.resources_check(script_path, resources)



import os
import sys
import time
import base64
import datetime
import threading
from functools import wraps
from __builtin__ import object

from sqlalchemy import Column, String, BINARY, BIGINT
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

import host
from helpers import init_logger, set_script_name


try:
    from host import service_create_person_folder
except ImportError:
    raise RuntimeError("You need to update Trassir")


GLOBALS = globals()

DEBUG = GLOBALS.get("DEBUG", False)
TYPE_OF_WORK = GLOBALS.get("TYPE_OF_WORK", "export")
DELETE_PERSONS = GLOBALS.get("DELETE_PERSONS", False)
UPDATE_SAME_PERSON = GLOBALS.get("UPDATE_SAME_PERSON", False)
FOLDER = GLOBALS.get("FOLDER", "{path}/face_from_folder")

IMPORT_FOLDER = FOLDER.format(
    path=host.settings("system_wide_options")["screenshots_folder"]
)

set_script_name("Face from folder")
logger = init_logger(name=host.stats().parent().name, debug=DEBUG)

engine = host.get_database_connection()
Session = sessionmaker(bind=engine)
session = Session()
Base = declarative_base()


class PersonImage(Base):
    __tablename__ = "persons_images_t"
    person_guid = Column(String(8))
    image_guid = Column(String(8), primary_key=True, nullable=False, unique=True)
    image = Column(BINARY)
    thumbnail = Column(BINARY)
    remote_server_guid = Column(String(8))
    modification_id = Column(BIGINT)
    deleted_ts = Column(BIGINT)

    @classmethod
    def get(cls):
        return session.query(cls)

    @classmethod
    def get_image(cls, person_guid):
        """

        Args:
            person_guid (str):

        Returns:
            (list | None): returns list of bytes

        """
        query = cls.get().filter(cls.person_guid == person_guid)

        if query is not None:
            images = [i.image for i in query]
            return images

    @classmethod
    def person_images_delete(cls, person_guid):
        """
        Args:
            person_guid (str):

        """
        try:
            query = cls.get().filter(cls.person_guid == person_guid)
            if query is None:
                logger.debug("Nothing to update")
                return
            indx = 0
            for indx, i in enumerate(query):
                i.image = None
            session.commit()
            logger.debug("data updated for %s images", indx)
        except Exception:
            logger.exception("Unhandled exception")


def run_as_thread(fn):
    """Run function as thread"""

    @wraps(fn)
    def run(*args, **kwargs):
        t = threading.Thread(target=fn, args=args, kwargs=kwargs)
        t.daemon = True
        t.start()
        return t

    return run


def person_image(person_guid):
    """
    Args:
        person_guid (str):
    """
    logger.debug("searching images for person guid: %s", person_guid)
    res = PersonImage.get_image(person_guid)
    return res


class Exporter(object):
    def __init__(self, base_path):
        self.base_path = unicode(base_path)

    def _get_folders(self, setting, current_path):
        # logger.debug("current path: %s", current_path)
        this_folder = (setting.guid, current_path)
        yield this_folder
        for obj in setting.ls():
            if obj.type == "PersonsSubFolder":
                new_folder = unicode(os.path.join(current_path, obj.name))
                for x in self._get_folders(obj, new_folder):
                    yield x

    def _make_path_name(self, fr_path):
        relative_path = os.path.relpath(fr_path, "persons")
        if relative_path == ".":
            full_path = self.base_path
        else:
            full_path = os.path.normpath(
                os.path.join(self.base_path, unicode(relative_path))
            )
        logger.debug("for fr_path (%s) full path is: %s", fr_path, full_path)
        if not os.path.isdir(full_path):
            try:
                os.makedirs(full_path)
            except OSError as err:
                logger.error(err)
                raise err
        return full_path

    @run_as_thread
    def collect_data(self):
        f = self._get_folders(host.settings("persons/"), "persons")
        folder_guid = None
        while True:
            try:
                folder_guid, path = f.next()
            except StopIteration:
                logger.debug("folder guid on stop iteration is %s", folder_guid)
                host.stats()["run_count"] += 1
                break

            search_filter = {"filter": {"folder_guids": [folder_guid]}}
            full_path = self._make_path_name(path)
            time_before = time.time()
            new_persons = host.service_get_persons(search_filter, 3)

            for record in new_persons.get("records", []):
                person_name = unicode(record.get("name"))
                gender = unicode(record.get("gender"))
                person_guid = record.get("guid")
                logger.debug("person name: %s", person_name)
                if not person_name:
                    logger.warning("person name not found for person guid: %s")
                    person_name = unicode(person_guid)
                imgs = person_image(person_guid)
                if not imgs:
                    logger.debug("no pi")
                    continue

                for count, img in enumerate(imgs, 1):
                    if count > 1:
                        file_name = u"{name}_{gender}_{count}.jpg".format(
                            name=person_name, gender=gender, count=count
                        )
                    else:
                        file_name = u"{name}_{gender}.jpg".format(
                            name=person_name, gender=gender
                        )

                    image_full_path = os.path.join(full_path, file_name)
                    with open(image_full_path, "wb") as of:
                        of.write(img)
            logger.debug(
                "download time for path: %s is: %s", path, time.time() - time_before
            )


class Importer(object):
    def __init__(self, source_path, delete_persons=False, update_same_person=False):
        if not os.path.exists(source_path):
            raise ValueError(host.tr("path not found: %s" % source_path))
        self.source_path = source_path
        self.gender_codes = {"male": 1, "female": 2, "other": 3}
        self.delete_persons = delete_persons
        self.update_same_person = update_same_person

    @staticmethod
    def _decode_image(path):
        with open(os.path.join(path), "rb") as image_file:
            encoded_string = base64.b64encode(image_file.read())
        return encoded_string

    @staticmethod
    def _split_path(rel_path):
        """

        Args:
            rel_path (str):

        Returns: (List(str))

        """
        res = []

        def _splitter(_path):
            p1, p2 = os.path.split(_path)
            logger.debug("_path: %s, p1: %s, p2: %s", _path, p1, p2)
            res.append(p2)
            if not p1:
                return
            _splitter(p1)

        _splitter(rel_path)
        res.reverse()
        return res

    def _create_path(self, rel_path):
        """

        Args:
            rel_path (str):

        Returns:

        """
        logger.debug("start create path: %s", rel_path)
        split_path = self._split_path(rel_path)
        logger.debug("split file: %s", split_path)
        relative_full_path = "persons"

        for path in split_path:
            parent_folder = host.settings("{path}".format(path=relative_full_path))
            relative_full_path = "/".join([relative_full_path, path])
            logger.debug("relative full path: %s", relative_full_path)
            try:
                host.settings("{path}".format(path=relative_full_path))
            except KeyError:
                ts_start = time.time()
                res = host.service_create_person_folder(
                    {"parent_guid": parent_folder.guid, "name": path}, 3
                )
                logger.info(
                    'folder "%s" created. Time for creation: %s. result: %s',
                    path,
                    time.time() - ts_start,
                    res,
                )

    def _create_person(self, path, name, folder_guid, gender, birthday="1980-01-01"):
        image_base64 = self._decode_image(path)
        person = host.service_person_create(
            name, folder_guid, birthday, gender, image_base64, 10
        )
        if not isinstance(person, dict):
            logger.error(
                "can't create person with name %s in folder: %s. Result: %s",
                name,
                folder_guid,
                person,
            )
            return
        if person.get("image"):
            person["image"] = "OK"
        logger.debug("person creation result: %s", person)

        return person.get("guid")

    def _relative_path(self, path):
        relative_path = path.split(self.source_path)[1]
        if relative_path.startswith("\\") or relative_path.startswith("/"):
            relative_path = relative_path[1:]
        rp = relative_path.replace("\\", "/")
        logger.debug("relative path: %s", rp)
        return rp

    @staticmethod
    def persons_in_facedb_folder(folder_obj):
        """

        Args:
            folder_obj ():

        Returns:
            Dict | None

        """
        search_filter = {"filter": {"folder_guids": [folder_obj.guid]}}
        persons = host.service_get_persons(search_filter, 3)
        records = persons.get("records")
        if not records:
            logger.debug("No records return")
            return
        if os.name == "nt":
            persons = {
                unicode(person.get("name")): person.get("guid") for person in records
            }
        else:
            persons = {person.get("name"): person.get("guid") for person in records}
        logger.debug(
            "collected persons dict in folder (%s): %s", folder_obj.path, persons
        )
        return persons

    def _split_file_name(self, file_name):
        person_data = file_name.split(".jpg")[0]
        person_data = person_data.split("_")
        person_name = person_data[0]
        try:
            person_gender = self.gender_codes.get(person_data[1], 1)
        except IndexError:
            person_gender = 1

        logger.debug(
            "person_data: %s, person name: %s, person gender: %s",
            person_data,
            person_name,
            person_gender,
        )
        return person_name, person_gender

    def _folder_obj(self, relative_path):
        """
        Check existence of a folder in Trassir face db.
        If folder doesn't exist this function calls _create_path to create it.

        Args:
            relative_path (str):

        Returns:
            Trassir host.object of folder

        """
        persons_folders_path = "persons/{path}".format(path=relative_path)
        try:
            folder_obj = host.settings(persons_folders_path)
            logger.debug("relative path found in fr db: %s", relative_path)
            folder_obj.path = persons_folders_path
            folder_obj.persons = self.persons_in_facedb_folder(folder_obj)
        except KeyError:
            logger.debug("relative path not found in fr db: %s", relative_path)
            self._create_path(relative_path)
            folder_obj = host.settings(persons_folders_path)
            folder_obj.persons = None
        return folder_obj

    def _update_person(self, person_guid, folder_guid, image_path):
        """

        Args:
            person_guid (str):
            folder_guid (str):
            image_path (str):

        """
        # person_image_delete(person_guid)
        img = self._decode_image(image_path)
        person_dict = {"folder_guid": folder_guid, "guid": person_guid, "image": img}
        result = host.service_update_person(person_dict, 3)
        if result.get("image"):
            result["image"] = "{} bytes".format(sys.getsizeof(result["image"]))
        if result.get("thumbnail"):
            result["thumbnail"] = "{} bytes".format(sys.getsizeof(result["thumbnail"]))
        logger.debug("person_update result: %s", result)

    @staticmethod
    def _delete_person(folder_obj):
        logger.debug(
            "going to delete persons in folder (%s): %s",
            folder_obj.path,
            folder_obj.persons,
        )
        for person_name, person_guid in folder_obj.persons.iteritems():
            person_dict = {"folder_guid": folder_obj.guid, "guid": person_guid}
            result = host.service_delete_person(person_dict, 3)
            logger.debug("result of delete: %s", result)

    @run_as_thread
    def upload_data(self):
        f = os.walk(unicode(self.source_path))
        while True:
            try:
                full_path, all_folders, all_files = next(f)
                logger.debug("full path: %s", full_path)
            except StopIteration:
                logger.debug("work done")
                host.stats()["run_count"] += 1
                break
            relative_path = self._relative_path(full_path)
            folder_obj = self._folder_obj(relative_path)

            for file_name in all_files:
                if not file_name.endswith(".jpg"):
                    continue
                person_name, person_gender = self._split_file_name(file_name)
                person_name = unicode(person_name)
                full_img_path = os.path.join(full_path, file_name)
                if folder_obj.persons:
                    logger.debug(
                        "person name: %s, person in all persons: %s, all persons: %s",
                        person_name,
                        person_name in folder_obj.persons,
                        folder_obj.persons,
                    )
                if folder_obj.persons and person_name in folder_obj.persons:
                    logger.debug(
                        "person with name %s and guid %s found on server in folder: %s, going to update image",
                        person_name,
                        folder_obj.persons.get(person_name),
                        relative_path if relative_path else "persons",
                    )
                    if self.update_same_person:
                        self._update_person(
                            folder_obj.persons.get(person_name),
                            folder_obj.guid,
                            full_img_path,
                        )
                    del folder_obj.persons[person_name]

                else:
                    logger.debug("going to create person with name: %s", person_name)
                    person_guid = self._create_person(
                        full_img_path, person_name, folder_obj.guid, person_gender
                    )
                    if person_guid:
                        logger.debug("Person created with guid: %s", person_guid)
                        host.service_fr_person_enroll(person_guid, 10)
                        time.sleep(0.1)

            if folder_obj.persons and self.delete_persons:
                self._delete_person(folder_obj)


# ----------------------------------------
#  Initializing
# ----------------------------------------
if __name__ != host.stats().parent().guid:
    raise EnvironmentError("Script run on Trassir server only")

if TYPE_OF_WORK == "import":
    IMPORT_FOLDER = os.path.normpath(IMPORT_FOLDER)
    assert os.path.isdir(IMPORT_FOLDER), host.tr("Source not found: %s" % IMPORT_FOLDER)
    logger.debug("source folder to upload data: %s", IMPORT_FOLDER)
    importer = Importer(IMPORT_FOLDER, DELETE_PERSONS, UPDATE_SAME_PERSON)
    importer.upload_data()
else:
    folder_name = "face_from_folder_{}".format(
        datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S")
    )
    destination_path = os.path.join(
        host.settings("system_wide_options")["screenshots_folder"], folder_name
    )
    exporter = Exporter(destination_path)
    exporter.collect_data()
