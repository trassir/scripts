# -*- coding: utf-8 -*-
# license counting v1.0.2
"""
<parameters>
    <company>EGUvarov, MNRudkovskyi</company>
    <title>license counting</title>
    <version>1.0.2</version>
    <parameter>
        <id>DEBUG</id>
        <type>boolean</type>
        <name>Debug mode</name>
        <value>False</value>
    </parameter>
    <resources>
        <resource>helpers.py</resource>
    </resources>
</parameters>
"""

resources = {
    "helpers.py": """
        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
        WIuvlCgz6f8DOZtdDw==
    """,
}
t1utils.resources_check(script_path, resources)

import os
import time
import host
from functools import wraps
import threading
import helpers

GLOBALS = globals()
DEBUG = GLOBALS.get("DEBUG", False)

helpers.set_script_name()
logger = helpers.init_logger("LicenseFree", debug=DEBUG)


def run_as_thread(func):
    """Run function as thread"""

    @wraps(func)
    def run(*args, **kwargs):
        thread = threading.Thread(target=func, args=args, kwargs=kwargs)
        thread.daemon = True
        thread.start()
        return thread

    return run


class RunUp:
    """parce license file and reconnect ip-dev according to license"""

    def __init__(self):
        self.all_device_dict = {
            x.guid: x["family"].upper().replace("-", "_")
            for x in host.settings("ip_cameras").ls()
            if x.type == "Grabber" and x["grabber_enabled"]
        }
        self.license_dict = {}
        self.license_list = [
            "DVS1_FULL",
            "DVS1_HIGH",
            "DVS1_MIDDLE",
            "DVS1_SILEN",
            "DVS1_WIDE",
            "DVS1_WIDE_OPTIMA",
            "DVS1_WIDE_SILEN",
            "DVS2_FULL",
            "DVS2_HIGH",
            "DVS2_MIDDLE",
            "DVS2_SILEN",
            "HYBRID",
            "TECHWELL",
            "V4L",
            "XVR",
            "DAHUA_RECORDER",
            "HIKDVR_RECORDER",
            "HIWATCH_RECORDER",
            "LTV_RECORDER",
            "NVR_RECORDER",
            "RVI_RECORDER",
            "HIKVISIONDVR",
            "TRASSIR_RECORDER",
            "VIVOTEK_RECORDER",
            "3S",
            "ACTI",
            "ACTIVECAM",
            "AKSILIUM",
            "AKTECHNOLOGY",
            "ALTERON",
            "AMATEK",
            "ANYFREE",
            "ANYIP",
            "APPRO",
            "ARECONT",
            "ASTROHN",
            "AVER",
            "AVTECH",
            "AXIS",
            "BERGER",
            "BESTDVR",
            "BESTIP",
            "BEWARD",
            "BOLID_IP",
            "BOSCH",
            "BRICKCOM",
            "BSP_SECURITY",
            "CONTOURHD",
            "DAHUA",
            "DALLMEIER",
            "DLINK",
            "DLINKPRO",
            "ETROVISION",
            "EVERFOCUS",
            "EVIDENCE",
            "FALCONEYE",
            "FLIR",
            "FSAN",
            "GEOVISION",
            "GRANDSTREAM",
            "GRUNDIG",
            "GTVS",
            "HIKVISION",
            "HIKVISIONDVR",
            "HIWATCH",
            "HIWATCH_REC",
            "HONEYWELL",
            "HUAWEI",
            "HUNT",
            "ICAM",
            "ICSM",
            "IDIS",
            "INFINITY",
            "IPTRONIC",
            "J2000",
            "JASSUN",
            "KAREL",
            "KEDACOM",
            "KENO",
            "LEVELONE",
            "LONGSE",
            "LTV",
            "MICRODIGITAL",
            "MILESIGHT",
            "MOBILECAM",
            "MOBOTIX",
            "NETPING",
            "NEUTRON",
            "NOVICAM",
            "NOVUS",
            "NVR",
            "OMNY",
            "ONVIF",
            "OPTIMUS",
            "PANASONIC",
            "PELCO",
            "USB",
            "POLYVISION",
            "PROGMATIC",
            "PROVIDEO",
            "QIHAN",
            "RTSP_MJPEG",
            "RTSP",
            "RVI",
            "SATVISION",
            "SIMPLEIP",
            "SMARTEC",
            "RTSP",
            "MJPEG" "SNR",
            "SONY",
            "SPACETECHNOLOGY",
            "SPEZVISION",
            "SUNELL",
            "SUNVISION",
            "SURVEON",
            "TANTOS",
            "TEB",
            "TECSAR",
            "TECSARLEAD",
            "TPTECHNOLOGY",
            "TRASSIR",
            "UNIVIEW",
            "USB_CAM",
            "VESTA",
            "VGUARD",
            "VISIONHITECH",
            "VIVOTEK",
            "WISENET_SAMSUNG",
            "YOKO",
            "ZAVIO",
        ]

        self.parce_file()

    def parce_file(self):
        with open(
            os.path.join(host.path_working(), " Trassir 3 License.txt"), "r"
        ) as f:
            for line in f.readlines():
                line_ = line.replace("\n", "")
                if "LICENSE" in line_:
                    first_split = line_.split(" ")
                    family = first_split[0].split("LICENSE_")[1]
                    if "RTSP" in family:
                        family = "RTSP"

                    num = int(first_split[-1:][0])
                    if family in self.license_list:
                        self.license_dict.update({family: num})

    @run_as_thread
    def reconnect(self):
        logger.debug("All device: %s", self.all_device_dict)
        dev_for_reboot_after = []
        for guid in self.all_device_dict:
            host.settings("ip_cameras/%s" % guid)["grabber_enabled"] = 0
            logger.debug(
                "GUID: %s off device. Setting: %s",
                guid,
                host.settings("ip_cameras/%s" % guid)["grabber_enabled"],
            )
        time.sleep(5)
        logger.debug("License dict: %s", self.license_dict)
        for guid, family in self.all_device_dict.iteritems():
            if family not in self.license_dict:
                host.settings("ip_cameras/%s" % guid)["grabber_enabled"] = 1
                logger.debug(
                    "GUID: %s, FAMILY: %s on device. Setting: %s",
                    guid,
                    family,
                    host.settings("ip_cameras/%s" % guid)["grabber_enabled"],
                )
            else:
                dev_for_reboot_after.append(guid)
                logger.debug(
                    "Add GUID: %s, FAMILY: %s to list after reboot", guid, family
                )
        time.sleep(5)
        for guid in dev_for_reboot_after:
            host.settings("ip_cameras/%s" % guid)["grabber_enabled"] = 1
            logger.debug(
                "After reboot. GUID: %s, on device. Setting: %s",
                guid,
                host.settings("ip_cameras/%s" % guid)["grabber_enabled"],
            )
        MatchLicense()


class MatchLicense:
    """license counting"""

    def __init__(self):
        self.all_device_dict = rp.all_device_dict
        self.license_dict = rp.license_dict
        self.error_dict = {}
        self.start = True
        self.counting()

    def counting(self):
        logger.debug("Start: %s" % self.start)
        self.write()
        self.start = False
        logger.debug("Start: %s" % self.start)
        for guid_ip_dev, family in self.all_device_dict.copy().iteritems():
            logger.debug("guid_ip_dev: %s, family: %s" % (guid_ip_dev, family))
            if family not in self.license_dict:
                if self.license_dict.get("ANYFREE"):
                    self.license_dict["ANYFREE"] -= 1
                    self.all_device_dict.pop(guid_ip_dev)
                    continue
                if self.license_dict.get("HYBRID"):
                    self.license_dict["HYBRID"] -= 1
                    self.all_device_dict.pop(guid_ip_dev)
                    continue
                if self.license_dict.get("ANYIP"):
                    self.license_dict["ANYIP"] -= 1
                    self.all_device_dict.pop(guid_ip_dev)
                    continue
        for guid_ip_dev, family in self.all_device_dict.iteritems():
            if family in self.license_dict:
                if self.license_dict[family] == 0:
                    continue
                self.license_dict[family] -= 1
            else:
                self.error_dict[guid_ip_dev] = family
        logger.debug("Start: %s" % self.start)
        self.write()
        host.message("Done!")

    def write(self):
        try:
            with open(
                host.settings("system_wide_options")["screenshots_folder"]
                + "/"
                + "License_Free.txt",
                "a",
            ) as f:
                if self.start:
                    f.write("В файле лицензии: \n")
                    logger.debug("В файле лицензии:")
                else:
                    f.write("Свободных лицензий: \n")
                    logger.debug("Свободных лицензий:")

                for name, count in self.license_dict.iteritems():
                    f.write("%s - %s \n" % (name, count))
                    logger.debug("%s - %s" % (name, count))
                if self.error_dict:
                    f.write("Не возможно лицензировать: \n")
                    logger.debug("Не возможно лицензировать:")
                    for name, family in self.error_dict.iteritems():
                        f.write("%s - %s \n" % (name, family))
                        logger.debug("%s - %s" % (name, family))
            f.close()
        except Exception as err:
            host.error("Error: %s" % err)
            logger.debug("Error: %s" % err)


old = os.path.join(
    host.settings("system_wide_options")["screenshots_folder"], "License_free.txt"
)
if os.path.isfile(old):
    os.remove(old)


rp = RunUp()
rp.reconnect()
