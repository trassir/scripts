# -*- coding: utf-8 -*-
# create_ip_from_csv v2.0.4
"""
<parameters>
    <company>DSSL</company>
    <authors>d.gavrilov</authors>
    <title>create_ip_from_csv</title>
    <version>2.0.4</version>
    <parameter>
        <id>FILE</id>
        <name>Absolute path to file(csv)</name>
        <type>string</type>
        <value></value>
    </parameter>
    <parameter>
        <id>SERVER</id>
        <name>Server</name>
        <type>server</type>
    </parameter>
    <parameter>
        <id>TIMEOUT</id>
        <name>Timeout between adding cameras(sec)</name>
        <type>integer</type>
        <min>1</min>
        <max>9999</max>
        <value>1</value>
    </parameter>
    <parameter>
        <id>AUTODETECT_TIMEOUT</id>
        <name>Timeout arming camera ONVIF/Autodetect(sec)</name>
        <type>integer</type>
        <min>1</min>
        <max>9999</max>
        <value>20</value>
    </parameter>
    <parameter>
        <id>COMMAND</id>
        <name>Command</name>
        <type>string_from_list</type>
        <string_list>create,delete</string_list>
        <value>create</value>
    </parameter>
    <parameter>
        <id>DEBUG</id>
        <type>boolean</type>
        <name>Debug mode</name>
        <value>False</value>
    </parameter>
    <resources>
        <resource>helpers.py</resource>
    </resources>
</parameters>
"""

resources = {
    "helpers.py": """
        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
        WIuvlCgz6f8DOZtdDw==
    """,
}
t1utils.resources_check(script_path, resources)

GLOBALS = globals()
FILE = GLOBALS.get("FILE", "")
SERVER = GLOBALS.get("SERVER", "")
COMMAND = GLOBALS.get("COMMAND", "create")
TIMEOUT = GLOBALS.get("TIMEOUT", 1)
AUTODETECT_TIMEOUT = GLOBALS.get("AUTODETECT_TIMEOUT", 20)
DEBUG = GLOBALS.get("DEBUG", False)

import helpers

helpers.set_script_name()
logger = helpers.init_logger("create_grabber_from_csv", debug=DEBUG)

import re
import time
import os
import host
from collections import defaultdict
import threading
from functools import wraps

if not SERVER:
    raise ValueError("Need select a server")
if not FILE:
    raise ValueError("Need to specify the absolute path to the .csv file")


def _run_as_thread(fn):
    @wraps(fn)
    def run(*args, **kwargs):
        t = threading.Thread(target=fn, args=args, kwargs=kwargs)
        t.daemon = True
        t.start()
        return t

    return run


remove_grabbers = COMMAND == "delete"
_ip_camera_add = host.settings("/{}/ip_cameras/ip_camera_add".format(SERVER))
available_grabbers = {}

for sett in _ip_camera_add.ls():
    if sett.type == "GrabberAddStep2":
        available_grabbers[sett.guid.lower()] = sett.guid


def clear_grabber_family(family):
    return available_grabbers.get(family.strip().lower())


class MainWorker:
    def __init__(self, server_guid, timeout, autodetect_timeout):
        self.server = host.settings("/%s" % server_guid)
        self.ip_cameras = self.server.cd("ip_cameras")
        self.timeout = timeout
        self.autodetect_timeout = autodetect_timeout
        assert self.ip_cameras
        self.ip_camera_add = self.ip_cameras.cd("ip_camera_add")
        assert self.ip_camera_add
        self.channels = self.server.cd("channels")
        assert self.channels
        logger.debug(
            "Script starting with params: server guid: %s, timeout: %s, autodetect_timeout: %s"
            % (self.server.guid, self.timeout, self.autodetect_timeout)
        )

    def create_grabber_from_csv(self, path_to_file, rm_grabbers):
        if os.path.isfile(path_to_file):
            filename, ext = os.path.splitext(path_to_file)
            if ext == ".csv":
                logger.debug("{filename} is a {ext} file".format(filename=filename, ext=ext))
                self._csv_reader(path_to_file, rm_grabbers)
            else:
                raise Warning("{filename} is a {ext} file. Need .csv extension".format(filename=filename, ext=ext))
        else:
            raise ValueError("File not found!")

    @staticmethod
    def _to_int(port):
        try:
            return int(port)
        except ValueError:
            return 0

    @staticmethod
    def _rename_grabbers(grabber_name, channel_name):
        if grabber_name and grabber_name == channel_name:
            grabber_name += "_"
        return grabber_name

    def _get_model(self, model):
        if model == "Autodetect":
            return model
        else:
            return model.upper()

    def get_conf(self, name, max_channels):
        idx = ""
        res = []
        if name != "":
            for i in xrange(0, max_channels):
                res.append({"i": i, "name": name + idx})
                idx = " %s" % (i + 1)
        return res

    def _csv_reader(self, path_to_file, rm_grabbers):
        try:
            config = defaultdict(list)
            with open(path_to_file) as _file:
                grabber_list = []
                count = 0
                next(_file)
                for row in _file:
                    if row.strip():
                        count += 1
                        row_data = re.split(r",|;|", row)
                        if rm_grabbers:
                            try:
                                port = self._to_int(row_data[1])
                            except IndexError:
                                port = 80
                            grabber_list.append(
                                "{ip}:{connection_port}".format(
                                    ip=row_data[0], connection_port=port
                                )
                            )
                        else:
                            family = clear_grabber_family(str(row_data[6]))
                            if family is None:
                                logger.warning("Family not found for %s", row_data)
                                continue
                            else:
                                config[family].append(
                                    {
                                        "channel_config": self.get_conf(
                                            row_data[5], 16
                                        ),
                                        "connection": {
                                            "connection_ip": row_data[0],
                                            "connection_port": self._to_int(
                                                row_data[1]
                                            ),
                                            "connection_username": row_data[2],
                                            "connection_password": row_data[3],
                                            "model": self._get_model(row_data[7]),
                                        },
                                        "grabber_config": {
                                            "name": self._rename_grabbers(
                                                row_data[4], row_data[5]
                                            )
                                        },
                                    }
                                )

                if not count:
                    raise ValueError("File is empty")
                if grabber_list:
                    self.remove_grabber_from_csv(grabber_list)
                    return

                self.create_grabber(config)

        except Exception as e:
            raise ValueError("Can't read the file! - %s" % e)

    @_run_as_thread
    def remove_grabber_from_csv(self, grabber_list):
        try:
            __del_count = 0
            logger.debug("starting delete grabber")
            exists_grabbers = self.check_grabbers_on_server()  # {"ip:port": "grabber_guid"}
            for grabber in grabber_list:
                if exists_grabbers.get(grabber):
                    self.ip_cameras["grabber_delete"] = exists_grabbers[grabber]
                    __del_count += 1
                    logger.debug("delete %s" % grabber)
                    time.sleep(1)
                else:
                    logger.debug("%s not found in exists grabbers" % grabber)
            if __del_count == 0:
                logger.warning("No cameras to delete")
            else:
                logger.warning("Delete done!")
        except:
            logger.exception("Unhandled exception in delete_grabber method...")

    @staticmethod
    def get_allocated_guid(search_key, ip_camera_add, conn, autodetect=False):
        logger.debug("search key %s", search_key)
        allocated_guid = ip_camera_add[search_key]
        max_tries_to_get_guid = 60
        while not allocated_guid and max_tries_to_get_guid:
            time.sleep(1)
            allocated_guid = ip_camera_add[search_key]
            logger.debug("try to get allocated guid")
            max_tries_to_get_guid -= 1
        if autodetect:
            ip_camera_add["load_dll"] = 1
            ip_camera_add["create_now"] = 1
        logger.debug("create grabber %s" % conn["connection_ip"])
        return allocated_guid

    @_run_as_thread
    def create_grabber(self, config):
        try:
            logger.debug("starting create grabber")
            exists_grabbers = self.check_grabbers_on_server()

            for family, grabbers in config.iteritems():
                ip_camera_add = self.ip_camera_add.cd(family)
                if ip_camera_add is None:
                    logger.warning("Family %s not found", family)
                    continue
                ip_camera_add["load_dll"] = 1
                time.sleep(1)
                host.stats()["run_count"] = len(grabbers)
                for grabber in grabbers:
                    conn = grabber["connection"]
                    logger.debug("conn %s", conn)
                    autodetect_timeout = self.autodetect_timeout
                    allocated_guid = exists_grabbers.pop(
                        "{s[connection_ip]}:{s[connection_port]}".format(s=conn), None
                    )
                    if allocated_guid is None:
                        try:
                            ip_camera_add["create_model"] = (
                                conn["model"] if family != "ONVIF" else "Autodetect"
                            )
                            ip_camera_add["create_address"] = conn["connection_ip"]
                            ip_camera_add["create_port"] = conn["connection_port"]
                            ip_camera_add["create_username"] = conn[
                                "connection_username"
                            ]
                            ip_camera_add["create_password"] = conn[
                                "connection_password"
                            ]
                            if family == "ONVIF" or conn["model"] == "Autodetect":
                                ip_camera_add["autodetect_result"] = "Detecting"
                                while ip_camera_add["autodetect_result"] == "Detecting":
                                    autodetect_timeout -= 1
                                    if not autodetect_timeout:
                                        ip_camera_add["autodetect_result"] = ""
                                        logger.warning(
                                            "cant detect cam with ip %s"
                                            % conn["connection_ip"]
                                        )
                                        break
                                    time.sleep(1)
                                if (
                                    "error"
                                    in ip_camera_add["autodetect_status"].lower()
                                ):
                                    logger.warning(ip_camera_add["autodetect_status"])
                                    host.stats()["run_count"] -= 1
                                    continue

                                allocated_guid = self.get_allocated_guid(
                                    "autodetect_status",
                                    ip_camera_add,
                                    conn,
                                    autodetect=False,
                                )
                            else:
                                allocated_guid = self.get_allocated_guid(
                                    "allocated_guid",
                                    ip_camera_add,
                                    conn,
                                    autodetect=True,
                                )

                            assert allocated_guid, "No allocated guid found..."
                            assert "error" not in allocated_guid.lower(), (
                                "Got some error while detecting... %s" % allocated_guid
                            )
                            logger.debug("allocated guid %s" % allocated_guid)
                        except:
                            logger.debug(
                                "Unhandled exception in create grabber", exc_info=True
                            )
                            host.stats()["run_count"] -= 1
                            continue
                    self.grabber_settings_setter(
                        allocated_guid,
                        grabber["grabber_config"],
                        grabber["channel_config"],
                    )
                    host.stats()["run_count"] -= 1
                    time.sleep(self.timeout)
        except:
            logger.exception("Unhandled exception")

    def check_grabbers_on_server(self):
        grabber_dict = {}
        for sett in host.settings("/{}/ip_cameras/".format(self.server.guid)).ls():
            if sett.type == "Grabber":
                grabber_dict[
                    "{s[connection_ip]}:{s[connection_port]}".format(s=sett)
                ] = sett.guid
        return grabber_dict

    def grabber_settings_setter(self, grabber_guid, grabber_config, channels_config):
        max_tries_to_get_grabber = 60
        name = grabber_config.pop("name", None)
        if name:
            grabber_config["name"] = name
        try:
            logger.debug("starting set grabbing settings")
            grabber = self.ip_cameras.cd(grabber_guid)
            while not grabber and max_tries_to_get_grabber:
                time.sleep(1)
                logger.debug("try to get grabber settings %s", name)
                grabber = self.ip_cameras.cd(grabber_guid)
                max_tries_to_get_grabber -= 1
            logger.debug("grabber settings %s " % grabber)
            if grabber is None:
                logger.critical("Cant set grabber settings %s", grabber_guid)
                return
            for key, value in grabber_config.iteritems():
                try:
                    if grabber[key] != value:
                        grabber[key] = value
                except KeyError:
                    logger.warning(
                        "Can't set settings('%s')[%s] = %s", grabber.path, key, value
                    )
            for channel_cfg in channels_config:
                i = channel_cfg.pop("i")
                channel_guid = grabber["channel{:02d}_guid".format(i)]
                if channel_guid:
                    self.channel_settings_setter(channel_guid, channel_cfg)
        except:
            logger.exception("Unhandled exception")

    def channel_settings_setter(self, channel_guid, channel_cfg):
        max_tries_to_get_channel = 60
        name = channel_cfg.pop("name", None)
        if name:
            channel_cfg["name"] = name
        try:
            logger.debug("starting set channel settings: %s", channel_guid)
            channel = self.channels.cd(channel_guid)
            logger.debug("grabber_settings_setter %s " % channel)
            while not channel and max_tries_to_get_channel:
                time.sleep(1)
                logger.debug("try to get channel settings %s", name)
                channel = self.channels.cd(channel_guid)
                max_tries_to_get_channel -= 1
            logger.debug("channel settings %s " % channel)
            if channel is None:
                logger.critical("Cant set channel settings %s", channel_guid)
                return
            for key, value in channel_cfg.iteritems():
                try:
                    channel[key] = value
                except KeyError:
                    logger.warning(
                        "Can't set settings('%s')[%s] = %s", channel.path, key, value
                    )
        except:
            logger.exception("Unhandled exception")


v = MainWorker(SERVER, TIMEOUT, AUTODETECT_TIMEOUT)
v.create_grabber_from_csv(FILE, remove_grabbers)
